<!doctype html>
<html>
<head>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <meta charset="utf-8"/>
  <title>Smart Cart Scanner — debug</title>
  <style>
    body{font-family:system-ui,Roboto,Arial;margin:0;padding:12px;background:#f6f7fb;color:#111}
    header{display:flex;align-items:center;gap:12px}
    video{width:100%;max-width:420px;border-radius:10px;background:#000;display:block}
    #status{padding:8px;border-radius:8px;background:#111;color:#fff;margin-top:8px}
    .small{font-size:13px;color:#444;margin-top:6px}
    button{margin:6px 6px 6px 0;padding:8px 10px;border-radius:8px}
    #frame{width:100%;max-width:420px;display:block;margin-top:8px;background:#222}
    #console{white-space:pre-wrap;background:#000;color:#0f0;padding:8px;border-radius:6px;margin-top:8px;max-height:180px;overflow:auto;font-family:monospace;font-size:12px}
    #upload{display:block;margin-top:8px}
  </style>
</head>
<body>
<header>
  <h3>Smart Cart — Scanner (debug)</h3>
</header>

<video id="video" autoplay playsinline muted></video>
<canvas id="frame" width="640" height="480" style="display:none"></canvas>
<div id="status">initialising…</div>
<div class="small">If camera stays black: check site permission, try a different browser, or use "Upload image" below.</div>

<div style="margin-top:8px">
  <button id="btn-retry">Retry camera</button>
  <button id="btn-switch">Switch camera (front/back)</button>
  <input id="upload" type="file" accept="image/*">
</div>

<div id="console"></div>

<script type="module">
  const PI_ADD_URL = (new URLSearchParams(location.search).get('pi')) || 'https://hypogeal-flynn-clamorous.ngrok-free.dev/add_item';
  const video = document.getElementById('video');
  const status = document.getElementById('status');
  const consoleEl = document.getElementById('console');
  const frameCanvas = document.getElementById('frame');
  const ctx = frameCanvas.getContext('2d');
  const upload = document.getElementById('upload');
  const btnRetry = document.getElementById('btn-retry');
  const btnSwitch = document.getElementById('btn-switch');

  let stream = null;
  let usingEnvironment = true; // prefer back camera
  let isRunning = false;

  function log(...args){
    console.log(...args);
    consoleEl.textContent += args.map(a => (typeof a === 'object'? JSON.stringify(a): String(a))).join(' ') + "\n";
    consoleEl.scrollTop = consoleEl.scrollHeight;
  }

  // try getUserMedia with various constraints
  async function startCamera(){
    stopCamera();
    status.textContent = 'requesting camera...';
    log('Attempting camera (environment=', usingEnvironment, ')');

    const constraintsList = [
      { video: { facingMode: { exact: "environment" }, width: {ideal:1280}, height:{ideal:720} } },
      { video: { facingMode: { ideal: "environment" }, width: {ideal:640}, height:{ideal:480} } },
      { video: { width: {ideal:640}, height:{ideal:480} } }
    ];

    // rotate constraints based on usingEnvironment
    const tryList = usingEnvironment ? constraintsList : constraintsList.slice().reverse();

    for (const c of tryList){
      try{
        stream = await navigator.mediaDevices.getUserMedia(c);
        video.srcObject = stream;
        await video.play();
        isRunning = true;
        status.textContent = 'camera live';
        log('Camera started with constraints:', c);
        // show one frame to canvas
        drawFrame();
        startDetectLoop();
        return;
      } catch(err){
        log('getUserMedia failed for constraints', c, err && err.name ? err.name : err);
        // continue trying next
      }
    }

    status.textContent = 'camera failed — check site permission or try a different browser';
    isRunning = false;
  }

  // stop stream
  function stopCamera(){
    if (stream){
      stream.getTracks().forEach(t => t.stop());
      stream = null;
      video.srcObject = null;
    }
    isRunning = false;
  }

  // capture and show single frame
  function drawFrame(){
    if (!isRunning) return;
    try {
      const w = video.videoWidth || frameCanvas.width;
      const h = video.videoHeight || frameCanvas.height;
      frameCanvas.width = w;
      frameCanvas.height = h;
      ctx.drawImage(video, 0, 0, w, h);
      frameCanvas.style.display = 'block';
    } catch(e){
      log('drawFrame error', e);
    }
  }

  // detection loop skeleton: just show frame periodically and log BarcodeDetector availability
  let detectTimer = null;
  async function startDetectLoop(){
    if (detectTimer) clearInterval(detectTimer);
    detectTimer = setInterval(() => {
      drawFrame();
    }, 500);

    // log API support
    if ('BarcodeDetector' in window){
      BarcodeDetector.getSupportedFormats().then(f => log('BarcodeDetector supported formats:', f)).catch(e=>log('BarcodeDetector getSupportedFormats err', e));
    } else {
      log('BarcodeDetector not supported. ZXing fallback will be used.');
    }
  }

  // upload fallback handling
  upload.addEventListener('change', async (ev) => {
    const file = ev.target.files && ev.target.files[0];
    if (!file) return;
    const img = new Image();
    img.onload = async () => {
      frameCanvas.width = img.width;
      frameCanvas.height = img.height;
      ctx.drawImage(img,0,0);
      status.textContent = 'image loaded — attempting decode';
      // try ZXing decode once
      try {
        const { BrowserMultiFormatReader } = await import('https://unpkg.com/@zxing/library@0.19.1/esm/index.js');
        const reader = new BrowserMultiFormatReader();
        const result = await reader.decodeFromCanvas(frameCanvas);
        log('ZXing decode result', result);
        if (result && result.getText) {
          await handleDetected(result.getText());
        } else {
          status.textContent = 'no barcode found in image';
        }
      } catch(err) {
        log('ZXing decode error', err);
        status.textContent = 'decode failed';
      }
    };
    img.src = URL.createObjectURL(file);
  });

  // basic handling of detected barcode
  async function handleDetected(raw){
    log('detected raw:', raw);
    status.textContent = 'detected: ' + raw;
    // mapping
    const mapping = { "8913000": {name:'Milk', price:60}, "8913001": {name:'Butter', price:80} };
    const entry = mapping[String(raw)];
    if (entry){
      status.textContent = `scanned: ${entry.name} ₹${entry.price}`;
      await postAddItem(entry.name, entry.price);
    } else {
      status.textContent = `unknown: ${raw} -> sending with price 0`;
      await postAddItem(raw, 0);
    }
  }

  // post to Pi (no change)
  async function postAddItem(name, price){
    try{
      const body = { name: String(name), price: Math.round(Number(price)||0) };
      const res = await fetch(PI_ADD_URL, { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(body) });
      if(!res.ok){
        const t = await res.text();
        throw new Error('server ' + res.status + ' ' + t);
      }
      log('posted', body);
    } catch(err){
      log('postAddItem failed', err);
    }
  }

  // simple barcode detection attempt using BarcodeDetector if available, else no-op
  let bd = null;
  async function tryBarcodeDetectorOnce(){
    if (!isRunning) return;
    if ('BarcodeDetector' in window){
      try {
        if (!bd) bd = new BarcodeDetector();
        const results = await bd.detect(video);
        if (results && results.length){
          await handleDetected(results[0].rawValue);
        }
      } catch(e){
        log('BarcodeDetector error', e);
      }
    } // else rely on manual upload or ZXing fallback
  }

  // periodic attempt to detect using BarcodeDetector
  setInterval(() => {
    tryBarcodeDetectorOnce();
  }, 700);

  // buttons
  btnRetry.addEventListener('click', () => {
    startCamera();
  });
  btnSwitch.addEventListener('click', () => {
    usingEnvironment = !usingEnvironment;
    log('switching camera, usingEnvironment=', usingEnvironment);
    startCamera();
  });

  // on page load try camera
  (async ()=>{
    log('page load; checking getUserMedia support');
    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia){
      status.textContent = 'getUserMedia not supported in this browser';
      log('getUserMedia not supported');
      return;
    }
    // request permission and start
    try {
      await navigator.mediaDevices.getUserMedia({ video: true });
      // start for real
      await startCamera();
    } catch(err){
      log('initial permission/gum request failed', err);
      status.textContent = 'permission denied or error — open browser site settings and allow camera';
    }
  })();
</script>
</body>
</html>